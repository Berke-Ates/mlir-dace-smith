#include "SDFG/Conversion/SDFGToGeneric/OpCreators.h"
#include "SDFG/Conversion/SDFGToGeneric/PassDetail.h"
#include "SDFG/Conversion/SDFGToGeneric/Passes.h"
#include "SDFG/Conversion/SDFGToGeneric/SymbolicParser.h"
#include "SDFG/Dialect/Dialect.h"
#include "SDFG/Utils/Utils.h"
#include "mlir/Dialect/ControlFlow/IR/ControlFlowOps.h"
#include "mlir/Dialect/Func/IR/FuncOps.h"
#include "mlir/Dialect/MemRef/IR/MemRef.h"
#include "mlir/IR/AsmState.h"
#include "mlir/IR/IRMapping.h"
#include "mlir/Transforms/DialectConversion.h"

using namespace mlir;
using namespace sdfg;
using namespace conversion;

// Maps state name to their generated block
llvm::StringMap<Block *> blockMap;
// Maps symbols to the generated allocation operation
llvm::StringMap<memref::AllocOp> symbolMap;
// HACK: Keeps track of processed EdgeOps
llvm::DenseSet<EdgeOp> processedEdges;

//
// SDFG -> func.func
// States -> block
// Edges ->
//       Default: cf.br
//       Condition: Insert block (false branch) => compute condition =>
//                  cf.cond_br
//       Assignment: Add assignments at the of the src block => cf.br
//
// Alloc -> memref.alloc
// Load -> memref.load
// Store -> memref.store
// Copy -> memref.copy
//
// Alloc Symbol -> memref.alloc (int64)
// Sym ->
//      If single symbol: memref.load
//      If expression: parse, build AST, create ops
//
// Return -> func.return
// Tasklet -> func.func + func.call
//
// Map -> affine.parallel, affine.for, scf.forall, scf.for
//

//===----------------------------------------------------------------------===//
// Target & Type Converter
//===----------------------------------------------------------------------===//

struct GenericTarget : public ConversionTarget {
  GenericTarget(MLIRContext &ctx) : ConversionTarget(ctx) {
    // Every Op in the SDFG Dialect is illegal
    addIllegalDialect<SDFGDialect>();
    // Implicit top level module operation is legal
    addLegalOp<ModuleOp>();
    // Operations generated by this pass are legal
    addLegalOp<func::FuncOp>();
    addLegalOp<func::ReturnOp>();
    addLegalOp<cf::BranchOp>();
    addLegalOp<cf::CondBranchOp>();
    addLegalOp<memref::AllocOp>();
    addLegalOp<memref::LoadOp>();
    addLegalOp<memref::StoreOp>();
    addLegalOp<memref::CopyOp>();
    addLegalOp<arith::ConstantIntOp>();
    addLegalOp<arith::AddIOp>();
    addLegalOp<arith::SubIOp>();
    addLegalOp<arith::MulIOp>();
    addLegalOp<arith::DivSIOp>();
    addLegalOp<arith::FloorDivSIOp>();
    addLegalOp<arith::RemSIOp>();
    addLegalOp<arith::OrIOp>();
    addLegalOp<arith::AndIOp>();
    addLegalOp<arith::XOrIOp>();
    addLegalOp<arith::ShLIOp>();
    addLegalOp<arith::ShRSIOp>();
    addLegalOp<arith::CmpIOp>();
    addLegalOp<arith::ExtSIOp>();
    // All other operations are illegal
    markUnknownOpDynamicallyLegal([](Operation *op) { return false; });
  }
};

class ToMemrefConverter : public TypeConverter {
public:
  ToMemrefConverter() {
    addConversion([](Type type) { return type; });
    addConversion(convertMemrefTypes);
  }

  static Optional<Type> convertMemrefTypes(Type type) {
    if (MemRefType mem = type.dyn_cast<MemRefType>()) {
      SmallVector<int64_t> ints;
      SmallVector<StringAttr> symbols;
      SmallVector<bool> shape;
      for (int64_t dim : mem.getShape()) {
        if (dim <= 0) {
          StringAttr sym =
              StringAttr::get(mem.getContext(), sdfg::utils::generateName("s"));
          symbols.push_back(sym);
          shape.push_back(false);
        } else {
          ints.push_back(dim);
          shape.push_back(true);
        }
      }
      SizedType sized = SizedType::get(mem.getContext(), mem.getElementType(),
                                       symbols, ints, shape);

      return ArrayType::get(mem.getContext(), sized);
    }
    return std::nullopt;
  }
};

//===----------------------------------------------------------------------===//
// Helpers
//===----------------------------------------------------------------------===//

// Creates operations that perform the symbolic expression
Value symbolicExpressionToMLIR(PatternRewriter &rewriter, Location loc,
                               StringRef symExpr,
                               llvm::StringMap<Value> refMap = {}) {
  std::unique_ptr<ASTNode> ast = SymbolicParser().parse(symExpr);
  if (!ast)
    emitError(loc, "failed to parse symbolic expression");

  return ast->codegen(rewriter, loc, symbolMap, refMap);
}

//===----------------------------------------------------------------------===//
// SDFG, State & Edge Patterns
//===----------------------------------------------------------------------===//

class SDFGToFunc : public OpConversionPattern<SDFGNode> {
public:
  using OpConversionPattern<SDFGNode>::OpConversionPattern;

  LogicalResult
  matchAndRewrite(SDFGNode op, OpAdaptor adaptor,
                  ConversionPatternRewriter &rewriter) const override {

    // Mark the entry state
    op.getEntryState()->setAttr("entry", rewriter.getBoolAttr(true));

    // Create a function and clone the sdfg body
    func::FuncOp funcOp =
        createFunc(rewriter, op.getLoc(), "sdfg_func",
                   op.getBody().getArgumentTypes(), {}, "public");
    funcOp.getBody().takeBody(op.getBody());

    rewriter.eraseOp(op);
    return success();
  }
};

class StateToBlock : public OpConversionPattern<StateNode> {
public:
  using OpConversionPattern<StateNode>::OpConversionPattern;

  LogicalResult
  matchAndRewrite(StateNode op, OpAdaptor adaptor,
                  ConversionPatternRewriter &rewriter) const override {
    // Split the current basic block at the current position
    Block *newBlock = rewriter.createBlock(rewriter.getBlock()->getParent());

    // Add the mapping from the sdfg.state's name to the new basic block
    blockMap[op.getName()] = newBlock;

    // Connect to init block if it's an entry state
    if (op->hasAttrOfType<BoolAttr>("entry") &&
        op->getAttrOfType<BoolAttr>("entry").getValue()) {
      rewriter.setInsertionPointToEnd(&newBlock->getParent()->front());
      createBranch(rewriter, op.getLoc(), {}, newBlock);
    }

    // Clone the operations from the sdfg.state's body into the new basic block
    rewriter.setInsertionPointToStart(newBlock);

    for (Operation &operation : op.getBody().getOps()) {
      rewriter.clone(operation);
    }

    // If there is an outward edge, do not add a return op
    for (EdgeOp edge : op->getParentRegion()->getOps<EdgeOp>()) {
      if (edge.getSrc().equals(op.getSymName())) {
        rewriter.eraseOp(op);
        return success();
      }
    }

    createReturn(rewriter, op.getLoc(), {});
    rewriter.eraseOp(op);
    return success();
  }
};

class EdgeToBranch : public OpConversionPattern<EdgeOp> {
public:
  using OpConversionPattern<EdgeOp>::OpConversionPattern;

  LogicalResult
  matchAndRewrite(EdgeOp op, OpAdaptor adaptor,
                  ConversionPatternRewriter &rewriter) const override {
    // If we don't have a condition or assignments, add a simple branch
    if (adaptor.getCondition().equals("1") && adaptor.getAssign().empty()) {
      rewriter.setInsertionPointToEnd(blockMap[adaptor.getSrc()]);
      createBranch(rewriter, op.getLoc(), {}, blockMap[adaptor.getDest()]);
      rewriter.eraseOp(op);
      return success();
    }

    Block *takenBlock = rewriter.createBlock(rewriter.getBlock()->getParent());
    llvm::StringMap<Value> refMap;
    // FIXME: Extend to variable amount of references
    refMap["ref"] = adaptor.getRef();

    if (!adaptor.getCondition().equals("1")) {
      // If we have a condition, create a second block (not taken path)
      Block *notTakenBlock =
          rewriter.createBlock(rewriter.getBlock()->getParent());
      rewriter.setInsertionPointToEnd(blockMap[adaptor.getSrc()]);
      // Compute condition
      Value condition = symbolicExpressionToMLIR(
          rewriter, op.getLoc(), adaptor.getCondition(), refMap);
      // Add conditional branch
      createCondBranch(rewriter, op.getLoc(), condition, takenBlock,
                       notTakenBlock);

      // Update blockMap
      blockMap[adaptor.getSrc()] = notTakenBlock;

      // If there is no other edge op for the source state, add return statement
      // to the new block
      bool hasEdge = false;

      for (EdgeOp edge : rewriter.getBlock()->getParent()->getOps<EdgeOp>()) {
        if (edge.getSrc().equals(adaptor.getSrc()) && edge != op &&
            !processedEdges.contains(edge)) {
          hasEdge = true;
          break;
        }
      }

      if (!hasEdge) {
        rewriter.setInsertionPointToEnd(notTakenBlock);
        createReturn(rewriter, op.getLoc(), {});
      }
    } else {
      rewriter.setInsertionPointToEnd(blockMap[adaptor.getSrc()]);
      createBranch(rewriter, op.getLoc(), {}, takenBlock);
      // No blockMap update because only one unconditial edge allowed per state
    }

    // Add assignments
    rewriter.setInsertionPointToStart(takenBlock);

    for (Attribute assignment : adaptor.getAssign())
      symbolicExpressionToMLIR(rewriter, op.getLoc(),
                               cast<StringAttr>(assignment), refMap);

    // Create simple branch to destination
    createBranch(rewriter, op.getLoc(), {}, blockMap[adaptor.getDest()]);

    rewriter.eraseOp(op);
    processedEdges.insert(op);
    return success();
  }
};

//===----------------------------------------------------------------------===//
// Access Node Patterns
//===----------------------------------------------------------------------===//

class AllocToAlloc : public OpConversionPattern<AllocOp> {
public:
  using OpConversionPattern<AllocOp>::OpConversionPattern;

  LogicalResult
  matchAndRewrite(AllocOp op, OpAdaptor adaptor,
                  ConversionPatternRewriter &rewriter) const override {
    return failure();
  }
};

class LoadToLoad : public OpConversionPattern<LoadOp> {
public:
  using OpConversionPattern<LoadOp>::OpConversionPattern;

  LogicalResult
  matchAndRewrite(LoadOp op, OpAdaptor adaptor,
                  ConversionPatternRewriter &rewriter) const override {
    return failure();
  }
};

class StoreToStore : public OpConversionPattern<StoreOp> {
public:
  using OpConversionPattern<StoreOp>::OpConversionPattern;

  LogicalResult
  matchAndRewrite(StoreOp op, OpAdaptor adaptor,
                  ConversionPatternRewriter &rewriter) const override {
    return failure();
  }
};

class CopyToCopy : public OpConversionPattern<CopyOp> {
public:
  using OpConversionPattern<CopyOp>::OpConversionPattern;

  LogicalResult
  matchAndRewrite(CopyOp op, OpAdaptor adaptor,
                  ConversionPatternRewriter &rewriter) const override {
    return failure();
  }
};

//===----------------------------------------------------------------------===//
// Symbol Patterns
//===----------------------------------------------------------------------===//

class AllocSymbolToAlloc : public OpConversionPattern<AllocSymbolOp> {
public:
  using OpConversionPattern<AllocSymbolOp>::OpConversionPattern;

  LogicalResult
  matchAndRewrite(AllocSymbolOp op, OpAdaptor adaptor,
                  ConversionPatternRewriter &rewriter) const override {
    return failure();
  }
};

class SymToOps : public OpConversionPattern<SymOp> {
public:
  using OpConversionPattern<SymOp>::OpConversionPattern;

  LogicalResult
  matchAndRewrite(SymOp op, OpAdaptor adaptor,
                  ConversionPatternRewriter &rewriter) const override {
    return failure();
  }
};

//===----------------------------------------------------------------------===//
// Tasklet Patterns
//===----------------------------------------------------------------------===//

class TaskletToFunc : public OpConversionPattern<TaskletNode> {
public:
  using OpConversionPattern<TaskletNode>::OpConversionPattern;

  LogicalResult
  matchAndRewrite(TaskletNode op, OpAdaptor adaptor,
                  ConversionPatternRewriter &rewriter) const override {
    return failure();
  }
};

class ReturnToReturn : public OpConversionPattern<ReturnOp> {
public:
  using OpConversionPattern<ReturnOp>::OpConversionPattern;

  LogicalResult
  matchAndRewrite(ReturnOp op, OpAdaptor adaptor,
                  ConversionPatternRewriter &rewriter) const override {
    return failure();
  }
};

//===----------------------------------------------------------------------===//
// Map & Consume Patterns
//===----------------------------------------------------------------------===//

class MapToParallel : public OpConversionPattern<MapNode> {
public:
  using OpConversionPattern<MapNode>::OpConversionPattern;

  LogicalResult
  matchAndRewrite(MapNode op, OpAdaptor adaptor,
                  ConversionPatternRewriter &rewriter) const override {
    return failure();
  }
};

class ConsumeToTODO : public OpConversionPattern<ConsumeNode> {
public:
  using OpConversionPattern<ConsumeNode>::OpConversionPattern;

  LogicalResult
  matchAndRewrite(ConsumeNode op, OpAdaptor adaptor,
                  ConversionPatternRewriter &rewriter) const override {
    // TODO: Write lowering for consume nodes
    return failure();
  }
};

//===----------------------------------------------------------------------===//
// Pass
//===----------------------------------------------------------------------===//

void populateSDFGToGenericConversionPatterns(RewritePatternSet &patterns,
                                             TypeConverter &converter) {
  MLIRContext *ctxt = patterns.getContext();

  patterns.add<SDFGToFunc>(converter, ctxt);
  patterns.add<StateToBlock>(converter, ctxt);
  patterns.add<EdgeToBranch>(converter, ctxt);
  patterns.add<AllocToAlloc>(converter, ctxt);
  patterns.add<LoadToLoad>(converter, ctxt);
  patterns.add<StoreToStore>(converter, ctxt);
  patterns.add<CopyToCopy>(converter, ctxt);
  patterns.add<AllocSymbolToAlloc>(converter, ctxt);
  patterns.add<SymToOps>(converter, ctxt);
  patterns.add<TaskletToFunc>(converter, ctxt);
  patterns.add<ReturnToReturn>(converter, ctxt);
  patterns.add<MapToParallel>(converter, ctxt);
  patterns.add<ConsumeToTODO>(converter, ctxt);
}

namespace {
struct SDFGToGenericPass
    : public sdfg::conversion::SDFGToGenericPassBase<SDFGToGenericPass> {
  void runOnOperation() override;
};
} // namespace

void SDFGToGenericPass::runOnOperation() {
  ModuleOp module = getOperation();

  GenericTarget target(getContext());
  ToMemrefConverter converter;

  RewritePatternSet patterns(&getContext());
  populateSDFGToGenericConversionPatterns(patterns, converter);

  if (applyFullConversion(module, target, std::move(patterns)).failed())
    signalPassFailure();
}

std::unique_ptr<Pass> conversion::createSDFGToGenericPass() {
  return std::make_unique<SDFGToGenericPass>();
}
